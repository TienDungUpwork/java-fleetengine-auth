// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.fleetengine.auth.token.factory.signer;

import static java.nio.charset.StandardCharsets.UTF_8;

import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.google.common.collect.ImmutableMap;
import com.google.fleetengine.auth.token.FleetEngineToken;
import com.google.fleetengine.auth.token.factory.signer.util.CommonConstants;
import com.google.fleetengine.auth.token.factory.signer.util.RSAPrivateKeyUtils;
import com.google.gson.Gson;
import com.google.gson.JsonObject;
import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.interfaces.RSAPrivateKey;
import java.security.spec.InvalidKeySpecException;
import java.util.logging.Logger;

/**
 * Signs Fleet Engine tokens directly with a provided private key. Private key can either be
 * provided directly or through the GCP generated key file.
 */
public final class LocalSigner implements Signer {

  private static final Logger logger = Logger.getLogger(LocalSigner.class.getName());

  // JWT claim name of the private key id provided in the header.
  private static final String JWT_CLAIM_HEADER_KID_PROPERTY = "kid";

  // Json property names on service account key files.
  private static final String CLIENT_EMAIL_PROPERTY = "client_email";
  private static final String PRIVATE_KEY_ID_PROPERTY = "private_key_id";
  private static final String PRIVATE_KEY_PROPERTY = "private_key";

  /** Client email. */
  private final String clientEmail;

  /** Id of private key used when signing tokens. */
  private final String privateKeyId;

  /** Private key used for signing tokens. */
  private final String privateKey;

  /**
   * Creates a local signer based on the given parameters.
   *
   * @param clientEmail client email used for issuer
   * @param privateKeyId id of the private kee
   * @param privateKey private key used for signing
   */
  public static LocalSigner create(String clientEmail, String privateKeyId, String privateKey) {
    return new LocalSigner(clientEmail, privateKeyId, privateKey);
  }

  /**
   * Creates a Local Signer from a service account key file generated by GCP.
   *
   * @param keyStream stream of the service account key file
   */
  public static LocalSigner create(InputStream keyStream) {
    JsonObject serviceAccountKey = readGCPKeyFile(keyStream);
    return new LocalSigner(
        serviceAccountKey.get(CLIENT_EMAIL_PROPERTY).getAsString(),
        serviceAccountKey.get(PRIVATE_KEY_ID_PROPERTY).getAsString(),
        serviceAccountKey.get(PRIVATE_KEY_PROPERTY).getAsString());
  }

  private LocalSigner(String clientEmail, String privateKeyId, String privateKey) {
    this.clientEmail = clientEmail;
    this.privateKeyId = privateKeyId;
    this.privateKey = privateKey;
  }

  /** {@inheritDoc} */
  @Override
  public FleetEngineToken sign(FleetEngineToken token) throws SigningTokenException {
    try {
      String signedToken =
          JWT.create()
              .withHeader(getHeader(this.privateKeyId))
              .withExpiresAt(token.expirationTimestamp())
              .withIssuer(this.clientEmail)
              .withSubject(this.clientEmail)
              .withAudience(token.audience())
              .withIssuedAt(token.creationTimestamp())
              .withClaim(
                  CommonConstants.JWT_CLAIM_AUTHORIZATION_PROPERTY,
                  token.authorizationClaims().toMap())
              .sign(getAlgorithm(this.privateKey));
      return token.toBuilder().setJwt(signedToken).build();
    } catch (InvalidKeySpecException e) {
      throw new SigningTokenException("Error while signing JWT.", e);
    }
  }

  private static JsonObject readGCPKeyFile(InputStream keyStream) {
    try (BufferedInputStream inputStream = new BufferedInputStream(keyStream);
        InputStreamReader reader = new InputStreamReader(inputStream, UTF_8)) {
      return new Gson().fromJson(reader, JsonObject.class);
    } catch (IOException exception) {
      logger.warning("Error reading service account key. Please verify your file.");
      throw new IllegalStateException(exception);
    }
  }

  /**
   * Generates a map with JWT headers containing private key ID information.
   *
   * @param keyId private key id.
   */
  private static ImmutableMap<String, Object> getHeader(String keyId) {
    return ImmutableMap.of(JWT_CLAIM_HEADER_KID_PROPERTY, keyId);
  }

  /**
   * Generates the algorithm being used to sign the JWT based on the provided private key string.
   *
   * @param key private key.
   * @throws InvalidKeySpecException if the provided private key is invalid.
   */
  private static Algorithm getAlgorithm(String key) throws InvalidKeySpecException {
    RSAPrivateKey privateKey = RSAPrivateKeyUtils.getPrivateKey(key);
    return Algorithm.RSA256(null, privateKey);
  }
}
